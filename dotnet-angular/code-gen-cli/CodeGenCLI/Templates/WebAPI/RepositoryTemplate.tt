<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="CodeGenCLI.CodeGenClasses" #>
<#@ import namespace="CodeGenCLI.Extensions" #>
using Microsoft.EntityFrameworkCore;
using System;
using System.Threading.Tasks;
using <#= !string.IsNullOrEmpty(config.WebAPI.NamespaceRoot) ? config.WebAPI.NamespaceRoot : config.Name #>.Models;

namespace <#= !string.IsNullOrEmpty(config.WebAPI.NamespaceRoot) ? config.WebAPI.NamespaceRoot : config.Name #>.DAL.Repositories
{
	/// <summary>
	/// The repository for <#= !string.IsNullOrEmpty(model.NamePlural) ? model.NamePlural : model.Name + "s" #> in the data access layer.
	/// </summary>
    public class <#= model.Name #>Repository : Repository<<#= model.Name #>>
    {
        private new readonly <#= config.Name #>Context context;

		/// <summary>
		/// The constructor of the <#= model.Name #> repository.
		/// </summary>
        public <#= model.Name #>Repository(<#= config.Name #>Context context) : base(context)
        {
            this.context = context;
        }

        // Additional functionality and overrides

		public async Task<<#= model.Name #>> GetWithLinkedEntitiesByIdAsync(Guid id)
        {
            return await this.context.<#= !string.IsNullOrEmpty(model.NamePlural) ? model.NamePlural : model.Name + "s" #>
<# foreach (CodeGenModelRelation relation in model.Relations.Where(r => r.Type == "one-to-many")) { #>
                .Include(x => x.<#= relation.Name #>)
<# } #>
<# foreach (CodeGenModelRelation relation in model.Relations.Where(r => r.Type == "many-to-one")) { #>
                .Include(x => x.<#= relation.Name #>)
<# } #>
<# foreach (CodeGenModelRelation relation in model.Relations.Where(r => r.Type == "many-to-many" && !string.IsNullOrEmpty(r.Through))) { #>
<# } #>
                .SingleOrDefaultAsync(x => x.Id == id);
        }

<# if (model.ManyToMany) { #>
<# CodeGenModelRelation manyToManyModel1 = model.Relations.Where(r => r.Required && r.Name == r.Model).First(); #>
<# CodeGenModelRelation manyToManyModel2 = model.Relations.Where(r => r.Required && r.Name == r.Model && !r.Equals(manyToManyModel1)).First(); #>
        public <#= model.Name #> GetBy<#= manyToManyModel1.Model #>And<#= manyToManyModel2.Model #>Id(Guid <#= manyToManyModel1.Model.ToCamelCase() #>Id, Guid <#= manyToManyModel2.Model.ToCamelCase() #>Id)
        {
            return this.context.<#= model.Name #>
                .Where(x => x.<#= manyToManyModel1.Model #>Id == <#= manyToManyModel1.Model.ToCamelCase() #>Id && x.<#= manyToManyModel2.Model #>Id == <#= manyToManyModel2.Model.ToCamelCase() #>Id)
                .SingleOrDefault();
        }

		public <#= model.Name #> GetBy<#= manyToManyModel2.Model #>And<#= manyToManyModel1.Model #>Id(Guid <#= manyToManyModel2.Model.ToCamelCase() #>Id, Guid <#= manyToManyModel1.Model.ToCamelCase() #>Id)
        {
            return this.context.<#= model.Name #>
                .Where(x => x.<#= manyToManyModel2.Model #>Id == <#= manyToManyModel2.Model.ToCamelCase() #>Id && x.<#= manyToManyModel1.Model #>Id == <#= manyToManyModel1.Model.ToCamelCase() #>Id)
                .SingleOrDefault();
        }
<# } #>
    }
}
